基本的にODriveみたいな感じで使えるようにしようとしています。

実用example
ベル直

# 0 構造説明
RogiMasterクラスは以下に依存しています
* RogiMaster_Base
* RogiMater_Axis
* PIDController

RogiMaster_Baseは、ODriveの制御モードや入力モードの定義、設定用構造体の定義を行っています。

RogiMater_Axisは以下の機能を提供し、RogiMasterクラスの実装を簡単化しています。
* 各軸の現在のトルク、速度（turns/s）、位置（turns）を保存します。（セッターゲッターが面倒なので、publicアクセスにしてますが、、）
* オペレーター=によって代入される制御量も保存します。
* コンストラクタで代入される、各コントロールモードに対するpidゲインを用い、calc_current関数は保存された現在の情報と目標に対する差で出力値を返します。これはCANメッセージ用に、int16_tにします。
* 上記のint16_tも下記の理由から保存します。

RogiMasterクラスは、あるC610/C620からのフィードバックが来たらその軸に対する制御量を計算し送信します。

**このとき、ロボマスの渋い仕様によるトラップがあるため注意が必要です。**
モーターid1〜4は0x200、5〜8は0x1FFで、電流を一斉に入力します。
つまり、フィードバックが来た軸のみ計算し、他の軸は前ステップでの入力をそのまま送信してあげるようにしないといけません。
なので、C620_axisはint16_tも保存するようにしています。
計算と送信遅すぎて、バッファ溜まりすぎたり、制御性悪すぎたりする場合は、接続台数N個分来るのを待ってから送るように変更します。



# 1　初期化周り
CANとRogiMaster_Configのインスタンスを入れます。
configは接続する個数分のstd::arrayにまとめて下さい。
configを読み込んで、CAN_axis型の各軸の情報を保持
